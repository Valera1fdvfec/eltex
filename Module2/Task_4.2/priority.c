#include "priority.h" 

// Создание и инициализация новой очереди
PriorityQueue* createQueue() {
    PriorityQueue* pq = (PriorityQueue*)malloc(sizeof(PriorityQueue));
    pq->head = NULL;
    return pq;
}

// Создание нового узла с заданными данными и приоритетом
Node* createNode(char* data, int priority) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    strncpy(newNode->data, data, MAX_DATA_LENGTH);
    newNode->priority = priority;
    newNode->next = NULL;
    return newNode;
}

// Добавление нового элемента в очередь с учетом приоритета
void enqueue(PriorityQueue* pq, char* data, int priority) {
    Node* newNode = createNode(data, priority);

    // Если очередь пуста или приоритет нового элемента выше головы
    if (pq->head == NULL || pq->head->priority > priority) {
        newNode->next = pq->head;
        pq->head = newNode;
    } else {
        Node* temp = pq->head;
        
        // Поиск позиции для вставки элемента в порядке приоритета
        while (temp->next != NULL && temp->next->priority <= priority) {
            temp = temp->next;
        }
        
        newNode->next = temp->next;
        temp->next = newNode;
    }
}

// Извлечение и удаление элемента с наивысшим приоритетом (головы очереди)
void dequeue(PriorityQueue* pq) {
    if (pq->head == NULL) {
        printf("Очередь пуста\n");
        return;
    }
    
    Node* temp = pq->head;
    pq->head = pq->head->next;  // Перемещаем голову на следующий элемент

    printf("Элемент с наивысшим приоритетом: Данные = %s, Приоритет = %d\n", temp->data, temp->priority);
    free(temp);
}

// Извлечение и удаление первого элемента с указанным приоритетом
void dequeueWithPriority(PriorityQueue* pq, int priority) {
    if (pq->head == NULL) {
        printf("Очередь пуста\n");
        return;
    }

    Node* temp = pq->head;
    Node* prev = NULL;

    // Поиск элемента с указанным приоритетом
    while (temp != NULL && temp->priority != priority) {
        prev = temp;
        temp = temp->next;
    }

    if (temp == NULL) {
        printf("Элемент с приоритетом %d не найден\n", priority);
    } else {
        printf("Извлечён элемент с приоритетом %d: Данные = %s\n", priority, temp->data);
        
        if (prev == NULL) {
            pq->head = temp->next;
        } else {
            prev->next = temp->next;
        }
        free(temp);
    }
}

// Извлечение и удаление первого элемента с приоритетом не ниже указанного
void dequeueWithMinPriority(PriorityQueue* pq, int minPriority) {
    if (pq->head == NULL) {
        printf("Очередь пуста\n");
        return;
    }

    Node* temp = pq->head;
    Node* prev = NULL;

    // Поиск первого элемента с приоритетом не ниже указанного
    while (temp != NULL && temp->priority < minPriority) {
        prev = temp;
        temp = temp->next;
    }

    if (temp == NULL) {
        printf("Элемент с приоритетом >= %d не найден\n", minPriority);
        return;
    }

    printf("Извлечён элемент с приоритетом %d или выше: Данные = %s, Приоритет = %d\n", minPriority, temp->data, temp->priority);
 
    if (prev == NULL) {
        pq->head = temp->next;
    } else {
        prev->next = temp->next;
    }
    free(temp);
}

// Вывод всех элементов очереди
void printQueue(PriorityQueue* pq) {
    if (pq->head == NULL) {
        printf("Очередь пуста\n");
        return;
    }
    Node* temp = pq->head;
    while (temp != NULL) {
        printf("Данные: %s, Приоритет: %d\n", temp->data, temp->priority);
        temp = temp->next;
    }
}
// Вывод всех элементов с приоритетом не ниже указанного, без удаления
void printAllWithMinPriority(PriorityQueue* pq, int minPriority) {
    if (pq->head == NULL) {
        printf("Очередь пуста\n");
        return;
    }

    Node* temp = pq->head;
    int found = 0;

    printf("Элементы с приоритетом не ниже %d:\n", minPriority);
    while (temp != NULL) {
        if (temp->priority >= minPriority) {
            printf("Данные: %s, Приоритет: %d\n", temp->data, temp->priority);
            found = 1;
        }
        temp = temp->next;
    }

    if (!found) {
        printf("Элементов с приоритетом >= %d не найдено\n", minPriority);
    }
}

// Освобождение памяти, выделенной под очередь
void deleteQueue(PriorityQueue* pq) {
    Node* temp = pq->head;
    while (temp != NULL) {
        Node* next = temp->next;
        free(temp);  // Удаление текущего узла
        temp = next;
    }
    free(pq);  // Удаление структуры очереди
}

// Автоматическое добавление в очередь случайно сгенерированных элементов
void autoGenerateData(PriorityQueue* pq, int count) {
    char data[AUTO_GENERATED_LENGTH + 1];
    int priority;

    for (int i = 0; i < count; i++) {
        for (int j = 0; j < AUTO_GENERATED_LENGTH; j++) {
            data[j] = 'A' + rand() % 26;  // Генерация случайной буквы
        }
        data[AUTO_GENERATED_LENGTH] = '\0';

        priority = rand() % 256;  // Случайный приоритет от 0 до 255
        enqueue(pq, data, priority);  // Добавление элемента в очередь
        printf("Сгенерирован элемент: Данные = %s, Приоритет = %d\n", data, priority);
    }
}

// Удаление первого элемента с указанным приоритетом
void deleteNodeWithPriority(PriorityQueue* pq, int priority) {
    if (pq->head == NULL) {
        printf("Очередь пуста\n");
        return;
    }

    Node* temp = pq->head;
    Node* prev = NULL;

    // Поиск элемента с указанным приоритетом
    while (temp != NULL && temp->priority != priority) {
        prev = temp;
        temp = temp->next;
    }

    if (temp == NULL) {
        printf("Элемент с приоритетом %d не найден\n", priority);
        return;
    }

    if (prev == NULL) {
        pq->head = temp->next;
    } else {
        prev->next = temp->next;
    }

    printf("Удалён элемент с приоритетом %d: Данные = %s\n", priority, temp->data);
    free(temp);
}
